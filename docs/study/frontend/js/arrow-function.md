# 화살표 함수

화살표 함수는 보다 짧고 간결한 함수 표현이 가능해서 많이 사용되는 함수 표현입니다. 그러나, `function` 키워드를 사용하여 만드는 일반적인 함수와 차이점이 있어, 주의하지 않고 사용하면 예기치 못한 오류를 마주할 수도 있습니다.

## 화살표 함수는 this를 바인딩하지 않습니다

```js
let obj = {
  hello: "world!",
  say: () => {
    console.log(this.hello);
  }
}

obj.say();
```

위 코드의 출력결과는 어떻게 될까요? 일반적인 생각으로, `say()` 메소드는 `obj` 객체의 멤버이므로, `say()`메소드에서 호출하는 `this.hello`는 `obj.hello`, 즉, 출력 결과는 `world!`가 될 것으로 예상할 수 있습니다.  
<br />
그러나, 실제 위 코드를 실행해보면 `undefined`가 출력되는 것을 볼 수 있습니다.  
<br />
일반함수는 호출 방식에 따라 `this`에 바인딩할 객체가 결정되는 반면, 화살표 함수의 `this`는 무조건 상위 스코프의 `this`를 가리킵니다. 또한, `prototype`, `arguments`, `super` 역시 존재하지 않고, 생성자로 사용할 수가 없습니다.  
<br />
위 코드에서 `undefined`가 출력된 것은, `say()` 메소드가 화살표 함수이기 때문에, 메소드 내의 `this`가 메소드를 소유한 `obj` 객체가 아닌, 상위 스코프인 `window` 객체, 즉 전역객체를 가리키기 때문에 발생한 현상입니다.  
<br />
이처럼, 객체의 메소드로 화살표 함수를 사용하면 예상치 못한 오류를 발생시킬 수 있습니다.

<br />
화살표 함수는 축약 문법을 지원하기 때문에, 콜백으로 짧은 함수를 넘겨야 할 때 유용하게 사용될 수 있습니다.

```js
/* 다음 네개의 메소드는 모두 동일한 결과를 출력합니다 */

let a = (param) => {
  return param + 10;
}

// 매개변수가 한개인 경우, 파라미터 괄호를 생략할 수 있습니다.
let b = param => {
  return param + 10;
}

// 본문이 한 줄인 경우, 본문 괄호를 생략할 수 있으며, 이 때 작성한 표현식의 값을 return 합니다.
let c = (param) => param + 10;

// 위 두 특성을 조합하여 사용할 수도 있습니다.
let d = param => param + 10;
```